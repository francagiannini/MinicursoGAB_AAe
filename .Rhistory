varpred <-kriging_grilla$var1.var
cord_X <- kriging_grilla$x
cord_Y <- kriging_grilla$y
tablapred <- cbind(cord_X,cord_Y,pred, varpred)
# Chunk 22
# Visualización interactiva
cols <-colorRampPalette(rev(brewer.pal(11, "Spectral"))) # Genero una paleta
muestra <- mapview(datos,zcol = "VUT", ceX ="VUT", layer.name ="Muestra", col.regions = cols, alpha=0)
pred_grilla <- rasterFromXYZ(tablapred[,1:3])
crs(pred_grilla) <-CRS("+init=epsg:22174")
mapapred_grilla <- mapview(pred_grilla,legend=T, col.regions =  cols, layer.name ="Predichos Grilla",na.color = "transparent")
var_grilla <- rasterFromXYZ(tablapred[,c(1,2,4)])
crs(var_grilla) <-CRS("+init=epsg:22174")
mapavar_grilla <- mapview(var_grilla,legend=T, col.regions =  cols, layer.name ="Varianza Predicci?n Grilla",na.color = "transparent")
crs(kriging_ejes) <-CRS("+init=epsg:22174")
mapapred_ejes <- mapview(kriging_ejes, zcol = "var1.pred", ceX ="var1.pred",col.regions =  cols, layer.name ="Predicho Ejes", alpha=0)
mapavar_ejes <- mapview(kriging_ejes, zcol = "var1.var", ceX ="var1.var",col.regions =  cols, layer.name ="Varianza Predicci?n Ejes", alpha=0)
muestra +  mapapred_grilla + mapavar_grilla + mapapred_ejes + mapavar_ejes
# Chunk 23
muestra_predichos <- muestra +  mapapred_ejes
muestra_predichos %>%
leafem::addLogo ("https://idecor.cba.gov.ar/wp-content/uploads/2017/07/cropped-logo-IDECOR.png",position = "topleft" , width = 180, height = 60) %>%
leafem::addHomeButton(extent(pred_grilla), "Ciudad de San Francisco" , position = "bottomright") %>%
addMiniMap(position = "bottomleft" , width = 150, height = 150)
# Chunk 24
muestra_predichos %>%
leafem::addLogo("https://media.giphy.com/media/7JyrFBoAqrFOYVWXLK/giphy.gif",
position = "topleft",offset.x = 5, offset.y = 100, width = 200, height = 200) %>%
# leafem::addHomeButton(ext = extent(r), "Ciudad de San Francisco" , position = "bottomright") %>%
addMiniMap(position = "bottomleft" , width = 100, height = 100)
save.image(file = "Dia1.RData")
library(gstat) #
library(geoR) #
library(mapview) #
library(raster) #
library(leaflet) #
library(RColorBrewer) #
library(PerformanceAnalytics) #
library(ggplot2) #
library(caret) #
library(parallel) #
load(file = "Dia1.RData")
mod_exp
mod_esf
attr(mod_exp, 'SSErr')
attr(mod_esf, 'SSErr')
set.seed(17)
kricv_mod_esf <- krige.cv(VUT~1, datos, mod_esf, nfold=10)
set.seed(17)
kricv_mod_exp <- krige.cv(VUT~1, datos, mod_exp, nfold=10)
bubble(kricv_mod_esf, "residual", main = "Residuos Esferico")
bubble(kricv_mod_exp, "residual", main = "Residuos Exponencial")
# Error medio de predicci?n (ME), cercano a cero mejor:
mean(kricv_mod_esf$residual)
mean(kricv_mod_exp$residual)
# Error medio absoluto (MAE)
mean(abs(kricv_mod_esf$residual))
mean(abs(kricv_mod_exp$residual))
# Error cuadratico medio de predicci?n (MSE), mas peque?o mejor
mean(kricv_mod_esf$residual^2)
#función
validacion <-function (fold, base, var.y) {
require(caret)
require(gstat)
require(sp)
datos <- read.table(base, head=T)
names(datos)[names(datos) == var.y] <- 'Y'
if (base=="petrel.txt") {
names(datos)[names(datos) == 'long'] <- 'x'
names(datos)[names(datos) == 'lat'] <- 'y'
}
seed <-7
set.seed(seed)
datos$id <- sample(rep(1:10, nrow(datos), length.out = nrow(datos)))
list <- 1:10
prediccion <- data.frame()
testset<- data.frame()
training<- subset(datos, id %in% list[-fold])
testing<- subset(datos, id %in% c(fold))
# Kriging Ordinario
train_ko = training
test_ko = testing
coordinates(train_ko)<-~x+y
coordinates(test_ko)<-~x+y
vario <- variogram(Y ~1, train_ko)
VF_vut_KO <- fit.variogram(vario, vgm(c("Sph", "Exp", "Gau")))
KO <- krige(Y~ 1, train_ko, test_ko, VF_vut_KO)
# Regression Kriging
train_ko = training
test_ko = testing
coordinates(train_ko)<-~x+y
coordinates(test_ko)<-~x+y
mlr <- lm(Y ~. -x -y -id, training)
pred_mlr = predict(mlr, newdata = test_ko)
inside_rk <- predict(mlr, newdata=train_ko)
train_ko$error_rk <- training$Y - inside_rk
vario_rk <- variogram(error_rk~1, train_ko, cutoff=2300)
model_rk_ko <- fit.variogram(vario_rk, vgm(c("Sph", "Exp", "Gau")))
test_k <- krige(error_rk~ 1 , train_ko, test_ko, model_rk_ko)
test_rk_ko <- pred_mlr + test_k$var1.pred
# Random Forest
#fitControl <- trainControl(method = "cv", number = 10)
fitControl <- trainControl(method = "none")
#mtry <-data.frame(mtry=2)
set.seed(seed)
rf <- train(Y ~ . -x -y -id, data=training,
method = "rf",
#tuneGrid =mtry,
trControl = fitControl,
verbose = FALSE)
test_rf <- predict(rf, newdata=testing)
# Random Forest + Kriging Ordinario
inside_rf <- predict(rf, newdata=training)
train_ko = training
test_ko = testing
coordinates(train_ko)<-~x+y
coordinates(test_ko)<-~x+y
train_ko$error_rf <- training$Y - inside_rf
vario_rf <- variogram(error_rf~1, train_ko, cutoff=2300)
model_rf_ko <- fit.variogram(vario_rf, vgm(c("Sph","Exp", "Gau")))
test_ko <- krige(error_rf~ 1 , train_ko, test_ko, model_rf_ko)
test_rf_ko <- test_rf + test_ko$var1.pred
# Tabla observados y predichos
testset <- rbind(testset, as.data.frame(testing[,"Y"]))
result <- data.frame(data.frame("x"=testing$x,
"y"=testing$y,
"k-fold"=fold,
"Observado"=testset[,1],
"KO"=KO$var1.pred,
"RK"=test_rk_ko,
"RF"=test_rf,
"RF_KO"=test_rf_ko))
return(result)
}
# Para correr validacion cruzada con la función
resultados <- do.call(rbind,lapply(1:10, validacion,base="meuse.txt", var.y="om"))
# Función para comparación de métodos
head(resultados)
tabla <- resultados[,4:8]
resumen <- function (j) {
ME <-mean(tabla [,j] - tabla[,"Observado"])
MAE <- mean(abs(tabla [,j] - tabla[,"Observado"]))
MAPE <- mean(abs(tabla [,j]-tabla[,"Observado"])/tabla[,"Observado"]) *100
MSE <- mean((tabla [,j]-tabla[,"Observado"])^2)
RMSE <-sqrt(mean((tabla [,j]-tabla[,"Observado"])^2))
nRMSE <-sqrt(MSE)/mean(tabla[,"Observado"]) *100
rLM <- lm(tabla [,j]~ tabla[,"Observado"])
R2 <- as.matrix(summary(rLM)$adj.r.squared)
mx <- mean(tabla[,"Observado"])
my <- mean(tabla [,j])
s2x <- var(tabla[,"Observado"])
s2y <- var(tabla [,j])
sxy <- mean((tabla[,"Observado"]-mx) * (tabla [,j]-my))
CCC <- 2 * sxy / (s2x + s2y + (mx - my)^2)
resumen <- data.frame("Modelo"=names(tabla [j]),ME, MAE,MAPE, MSE, RMSE, nRMSE,R2,CCC)
return(resumen)
}
tablafinal <- do.call("rbind",lapply(2:5,resumen))
tablafinal
datos_meuse <- read.table("meuse.txt", head=T)
names(datos_meuse)
datos_petrel <- read.table("petrel.txt", head=T)
names(datos_petrel) # mud es asimetrica!!!
names(datosAP)
datosAP <- read.table("datosAP.txt", head=T)
names(datosAP)
resultadosAP <- do.call(rbind,lapply(1:10, validacion,base=datosAP, var.y="RindeSoja"))
resultadosAP <- do.call(rbind,lapply(1:10, validacion,base="datosAP.txt", var.y="RindeSoja"))
tabla <- resultadosAP[,4:8]
resultadosAP
tabla
head(resultadosAP)
tabla <- resultadosAP[,4:8]
tablafinal <- do.call("rbind",lapply(2:5,resumen))
tablafinal
head(resultadosAP)
tablafinal_AP <- do.call("rbind",lapply(2:5,resumen))
tablafinal_AP
resultados_meuse <- do.call(rbind,lapply(1:10, validacion,base="datosAP.txt", var.y="RindeSoja"))
resultados_meuse <- do.call(rbind,lapply(1:10, validacion,base="meuse.txt", var.y="om"))
head(resultados_meuse)
tabla <- resultados_meuse[,4:8]
tablafinal_meuse <- do.call("rbind",lapply(2:5,resumen))
knitr::include_graphics("VC1.jpg")
knitr::include_graphics("RK1.jpg")
knitr::include_graphics("cart.jpg")
# Chunk 1: setup
knitr::opts_chunk$set(echo = FALSE)
options(htmltools.dir.version=FALSE)
# Chunk 2
library(gstat) #
library(geoR) #
library(mapview) #
library(raster) #
library(leaflet) #
library(RColorBrewer) #
library(PerformanceAnalytics) #
library(ggplot2) #
library(caret) #
library(parallel) #
load(file = "Dia1.RData")
# Chunk 3
knitr::include_graphics("VC1.jpg")
# Chunk 4
mod_exp
mod_esf
attr(mod_exp, 'SSErr')
attr(mod_esf, 'SSErr')
set.seed(17)
kricv_mod_esf <- krige.cv(VUT~1, datos, mod_esf, nfold=10)
set.seed(17)
kricv_mod_exp <- krige.cv(VUT~1, datos, mod_exp, nfold=10)
bubble(kricv_mod_esf, "residual", main = "Residuos Esferico")
bubble(kricv_mod_exp, "residual", main = "Residuos Exponencial")
# Error medio de predicción (ME), cercano a cero mejor:
mean(kricv_mod_esf$residual)
mean(kricv_mod_exp$residual)
# Error medio absoluto (MAE)
mean(abs(kricv_mod_esf$residual))
mean(abs(kricv_mod_exp$residual))
# Error cuadratico medio de predicción (MSE), mas pequeño mejor
mean(kricv_mod_esf$residual^2)
mean(kricv_mod_exp$residual^2)
# Mean squared deviation ratio (MSDR), Error cuadratico medio normalizado, cercano a 1 mejor
mean(kricv_mod_esf$zscore^2)
mean(kricv_mod_exp$zscore^2)
# RMSE relativo a la media
sqrt(mean(kricv_mod_esf$residual^2))/mean(kricv_mod_esf$observed)*100
sqrt(mean(kricv_mod_exp$residual^2))/mean(kricv_mod_exp$observed)*100
# Correlación lineal entre valores observados y predichos
cor(kricv_mod_esf$observed, kricv_mod_esf$observed - kricv_mod_esf$residual)
cor(kricv_mod_exp$observed, kricv_mod_exp$observed - kricv_mod_exp$residual)
# Correlación lineal entre valores observados y predichos
par(mfrow=c(1,2))
plot(kricv_mod_esf$observed,kricv_mod_esf$observed - kricv_mod_esf$residual, xlab="Observados", ylab="Predichos")
plot(kricv_mod_exp$observed,kricv_mod_exp$observed - kricv_mod_exp$residual,xlab="Observados", ylab="Predichos")
# Chunk 5
knitr::include_graphics("RK1.jpg")
# Chunk 6
#1 Ajuste de modelo de RLM
mlr <- lm(VUT~g_porc_edi+ d_supcom + d_centro + d_indust + d_front , datos)
#2 Incorporamos los residuos del MLR a la base de datos
datos$residuos <-mlr$residuals
names(datos)
#3 Ajuste de semivariograma experimetal y te?rico a los reiuduos
semiv_rk <- variogram(residuos~1 , datos)
plot(semiv_rk)
semiv_rk <- variogram(residuos~1 , datos, cutoff=2300)
plot(semiv_rk)
v.fit_vut_rk <- fit.variogram(semiv_rk ,vgm(c("Exp","Sph","Gau")))
plot(semiv_rk ,v.fit_vut_rk)
#4 Kriging sobre residuos
kgres <- krige(residuos~1, datos, ejes, model = v.fit_vut_rk)
spplot(kgres["var1.pred"], main = "Kriging Residual: Predicciones", col.regions=terrain.colors(20))
#5 Predicción final
ejes$RK_pred <- predict(mlr, newdata=ejes) + kgres$var1.pred
spplot(ejes["RK_pred"], main = "Predicci?n RK", col.regions=terrain.colors(20))
mapapred_ejesRK <- mapview(ejes, zcol = "RK_pred", ceX ="RK_pred",col.regions =  cols, layer.name ="Predicho Ejes RK", alpha=0)
muestra +  mapapred_grilla + mapapred_ejes + mapapred_ejesRK
# Chunk 7
knitr::include_graphics("cart.jpg")
# Chunk 8
knitr::include_graphics("RF1.jpg")
# Chunk 9
datos <- read.table("datosSF_depurados.txt", header = T)
#1 Ajuste del RF con librer?a caret
seed <-7
#2 grilla de valores para mtry a evaluar
mtry <-expand.grid(mtry=seq(2,5,1))
#3 opciones de validaci?n
fitControl <- trainControl(method = "cv",number=10, allowParallel = T)
# opciones para praralelizado
# library(parallel)
# library(doParallel)
# cluster <- makeCluster(detectCores() - 1)
# registerDoParallel(cluster)
#4 ajuste del modelo de RF
set.seed(seed)
train_rf <- train(VUT ~ g_porc_edi + d_supcom + d_centro + d_indust + d_front,
data=datos,
method = "rf",
importance=T,
tuneGrid =mtry,
trControl = fitControl)
#5 Incorporamos los residuos del MLR a la base de datos
datos$residuosRF <-datos$VUT - predict(train_rf, newdata=datos)
#6 Ajuste de semivariograma experimetal y teórico a los residuos del RF
coordinates(datos) <- c("x", "y")
crs(datos) <- CRS("+init=epsg:22174")
semiv_RFk <- variogram(residuosRF~1 , datos)
plot(semiv_RFk)
semiv_RFk <- variogram(residuosRF~1 , datos, cutoff=2300)
plot(semiv_RFk)
v.fit_vut_RFk <- fit.variogram(semiv_RFk ,vgm(c("Exp","Sph","Gau")))
plot(semiv_RFk ,v.fit_vut_RFk)
#7 Kriging sobre residuos del RF
kgresRF <- krige(residuosRF~1, datos, ejes, model = v.fit_vut_RFk)
spplot(kgresRF["var1.pred"], main = "Kriging Residual (RF): Predicciones", col.regions=terrain.colors(20))
#8 Predicción final RF
ejes$RFK_pred <- predict(train_rf, newdata=ejes) + kgresRF$var1.pred
spplot(ejes["RFK_pred"], main = "Predicci?n RFK", col.regions=terrain.colors(20))
mapapredejes_RFK <- mapview(ejes, zcol = "RFK_pred", ceX ="RFK_pred",col.regions =  cols, layer.name ="Predicho Ejes RFK", alpha=0)
muestra +  mapapred_grilla + mapapred_ejes +  mapapred_ejesRK + mapapredejes_RFK
# Chunk 10
#Función validación
validacion <-function (fold, base, var.y) {
require(caret)
require(gstat)
require(sp)
datos <- read.table(base, head=T)
names(datos)[names(datos) == var.y] <- 'Y'
if (base=="petrel.txt") {
names(datos)[names(datos) == 'long'] <- 'x'
names(datos)[names(datos) == 'lat'] <- 'y'
}
seed <-7
set.seed(seed)
datos$id <- sample(rep(1:10, nrow(datos), length.out = nrow(datos)))
list <- 1:10
prediccion <- data.frame()
testset<- data.frame()
training<- subset(datos, id %in% list[-fold])
testing<- subset(datos, id %in% c(fold))
# Kriging Ordinario
train_ko = training
test_ko = testing
coordinates(train_ko)<-~x+y
coordinates(test_ko)<-~x+y
vario <- variogram(Y ~1, train_ko)
VF_vut_KO <- fit.variogram(vario, vgm(c("Sph", "Exp", "Gau")))
KO <- krige(Y~ 1, train_ko, test_ko, VF_vut_KO)
# Regression Kriging
train_ko = training
test_ko = testing
coordinates(train_ko)<-~x+y
coordinates(test_ko)<-~x+y
mlr <- lm(Y ~. -x -y -id, training)
pred_mlr = predict(mlr, newdata = test_ko)
inside_rk <- predict(mlr, newdata=train_ko)
train_ko$error_rk <- training$Y - inside_rk
vario_rk <- variogram(error_rk~1, train_ko, cutoff=2300)
model_rk_ko <- fit.variogram(vario_rk, vgm(c("Sph", "Exp", "Gau")))
test_k <- krige(error_rk~ 1 , train_ko, test_ko, model_rk_ko)
test_rk_ko <- pred_mlr + test_k$var1.pred
# Random Forest
#fitControl <- trainControl(method = "cv", number = 10)
fitControl <- trainControl(method = "none")
#mtry <-data.frame(mtry=2)
set.seed(seed)
rf <- train(Y ~ . -x -y -id, data=training,
method = "rf",
#tuneGrid =mtry,
trControl = fitControl,
verbose = FALSE)
test_rf <- predict(rf, newdata=testing)
# Random Forest + Kriging Ordinario
inside_rf <- predict(rf, newdata=training)
train_ko = training
test_ko = testing
coordinates(train_ko)<-~x+y
coordinates(test_ko)<-~x+y
train_ko$error_rf <- training$Y - inside_rf
vario_rf <- variogram(error_rf~1, train_ko, cutoff=2300)
model_rf_ko <- fit.variogram(vario_rf, vgm(c("Sph","Exp", "Gau")))
test_ko <- krige(error_rf~ 1 , train_ko, test_ko, model_rf_ko)
test_rf_ko <- test_rf + test_ko$var1.pred
# Tabla observados y predichos
testset <- rbind(testset, as.data.frame(testing[,"Y"]))
result <- data.frame(data.frame("x"=testing$x,
"y"=testing$y,
"k-fold"=fold,
"Observado"=testset[,1],
"KO"=KO$var1.pred,
"RK"=test_rk_ko,
"RF"=test_rf,
"RF_KO"=test_rf_ko))
return(result)
}
# Para correr validacion cruzada con la función
#resultados <- do.call(rbind,lapply(1:10, validacion,base="meuse.txt", var.y="om"))
# correr validacion cruzada paralelizado
#num_cores <- detectCores()-1
#cl <- makeCluster(num_cores)
#system.time(resultados <-do.call(rbind,parLapply(cl, 1:10, validacion, #base="meuse.txt", var.y="om")))
# Función para comparación de métodos
#head(resultados)
#tabla <- resultados[,4:8]
resumen <- function (j) {
ME <-mean(tabla [,j] - tabla[,"Observado"])
MAE <- mean(abs(tabla [,j] - tabla[,"Observado"]))
MAPE <- mean(abs(tabla [,j]-tabla[,"Observado"])/tabla[,"Observado"]) *100
MSE <- mean((tabla [,j]-tabla[,"Observado"])^2)
RMSE <-sqrt(mean((tabla [,j]-tabla[,"Observado"])^2))
nRMSE <-sqrt(MSE)/mean(tabla[,"Observado"]) *100
rLM <- lm(tabla [,j]~ tabla[,"Observado"])
R2 <- as.matrix(summary(rLM)$adj.r.squared)
mx <- mean(tabla[,"Observado"])
my <- mean(tabla [,j])
s2x <- var(tabla[,"Observado"])
s2y <- var(tabla [,j])
sxy <- mean((tabla[,"Observado"]-mx) * (tabla [,j]-my))
CCC <- 2 * sxy / (s2x + s2y + (mx - my)^2)
resumen <- data.frame("Modelo"=names(tabla [j]),ME, MAE,MAPE, MSE, RMSE, nRMSE,R2,CCC)
return(resumen)
}
# Ver resultados finales
#tablafinal <- do.call("rbind",lapply(2:5,resumen))
#tablafinal
# Chunk 11
resultadosAP <- do.call(rbind,lapply(1:10, validacion,base="datosAP.txt", var.y="RindeSoja"))
head(resultadosAP)
tabla <- resultadosAP[,4:8]
tablafinal_AP <- do.call("rbind",lapply(2:5,resumen))
tablafinal_AP
# Chunk 12
resultados_meuse <- do.call(rbind,lapply(1:10, validacion,base="meuse.txt", var.y="om"))
head(resultados_meuse)
tabla <- resultados_meuse[,4:8]
tablafinal_meuse <- do.call("rbind",lapply(2:5,resumen))
tablafinal_meuse
# Chunk 13
resultados_petrel <- do.call(rbind,lapply(1:10, validacion,base="petrel.txt", var.y="mud"))
head(resultados_petrel)
tabla <- resultados_petrel[,4:8]
tablafinal_petrel <- do.call("rbind",lapply(2:5,resumen))
tablafinal_petrel # mud es asimetrica!!!
load(file = "Dia1.RData", verbose = TRUE)
load(file = "Dia1.RData", verbose = TRUE)
library(mapview) #
library(gstat) #
library(geoR) #
library(mapview) #
library(raster) #
library(leaflet) #
library(RColorBrewer) #
library(PerformanceAnalytics) #
library(ggplot2) #
library(caret) #
library(parallel) #
load(file = "Dia1.RData", verbose = TRUE)
#1 Ajuste de modelo de RLM
mlr <- lm(VUT~g_porc_edi+ d_supcom + d_centro + d_indust + d_front , datos)
#2 Incorporamos los residuos del MLR a la base de datos
datos$residuos <-mlr$residuals
names(datos)
#3 Ajuste de semivariograma experimetal y te?rico a los reiuduos
semiv_rk <- variogram(residuos~1 , datos)
plot(semiv_rk)
semiv_rk <- variogram(residuos~1 , datos, cutoff=2300)
plot(semiv_rk)
v.fit_vut_rk <- fit.variogram(semiv_rk ,vgm(c("Exp","Sph","Gau")))
plot(semiv_rk ,v.fit_vut_rk)
#4 Kriging sobre residuos
kgres <- krige(residuos~1, datos, ejes, model = v.fit_vut_rk)
spplot(kgres["var1.pred"], main = "Kriging Residual: Predicciones", col.regions=terrain.colors(20))
#5 Predicción final
ejes$RK_pred <- predict(mlr, newdata=ejes) + kgres$var1.pred
spplot(ejes["RK_pred"], main = "Predicci?n RK", col.regions=terrain.colors(20))
mapapred_ejesRK <- mapview(ejes, zcol = "RK_pred", ceX ="RK_pred",col.regions =  cols, layer.name ="Predicho Ejes RK", alpha=0)
muestra +  mapapred_grilla + mapapred_ejes + mapapred_ejesRK
# Chunk 1: setup
knitr::opts_chunk$set(echo = FALSE)
options(htmltools.dir.version=FALSE)
# Chunk 2
library(gstat) #
library(geoR) #
library(mapview) #
library(raster) #
library(leaflet) #
library(RColorBrewer) #
library(PerformanceAnalytics) #
library(ggplot2) #
library(caret) #
library(parallel) #
load(file = "Dia1.RData", verbose = TRUE)
# Chunk 3
knitr::include_graphics("VC1.jpg")
# Chunk 4
mod_exp
mod_esf
attr(mod_exp, 'SSErr')
attr(mod_esf, 'SSErr')
set.seed(17)
kricv_mod_esf <- krige.cv(VUT~1, datos, mod_esf, nfold=10)
set.seed(17)
kricv_mod_exp <- krige.cv(VUT~1, datos, mod_exp, nfold=10)
bubble(kricv_mod_esf, "residual", main = "Residuos Esferico")
bubble(kricv_mod_exp, "residual", main = "Residuos Exponencial")
# Error medio de predicción (ME), cercano a cero mejor:
mean(kricv_mod_esf$residual)
mean(kricv_mod_exp$residual)
# Error medio absoluto (MAE)
mean(abs(kricv_mod_esf$residual))
mean(abs(kricv_mod_exp$residual))
# Error cuadratico medio de predicción (MSE), mas pequeño mejor
mean(kricv_mod_esf$residual^2)
mean(kricv_mod_exp$residual^2)
# Mean squared deviation ratio (MSDR), Error cuadratico medio normalizado, cercano a 1 mejor
mean(kricv_mod_esf$zscore^2)
mean(kricv_mod_exp$zscore^2)
# RMSE relativo a la media
sqrt(mean(kricv_mod_esf$residual^2))/mean(kricv_mod_esf$observed)*100
sqrt(mean(kricv_mod_exp$residual^2))/mean(kricv_mod_exp$observed)*100
# Correlación lineal entre valores observados y predichos
cor(kricv_mod_esf$observed, kricv_mod_esf$observed - kricv_mod_esf$residual)
cor(kricv_mod_exp$observed, kricv_mod_exp$observed - kricv_mod_exp$residual)
# Correlación lineal entre valores observados y predichos
par(mfrow=c(1,2))
plot(kricv_mod_esf$observed,kricv_mod_esf$observed - kricv_mod_esf$residual, xlab="Observados", ylab="Predichos")
plot(kricv_mod_exp$observed,kricv_mod_exp$observed - kricv_mod_exp$residual,xlab="Observados", ylab="Predichos")
# Chunk 5
knitr::include_graphics("RK1.jpg")
